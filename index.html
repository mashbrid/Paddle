<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paddle Controller</title>
    <style>
        /* Basic body styling */
        body {
            font-family: Arial, sans-serif; /* Set the font for the entire page */
            text-align: center; /* Center-align the text */
            margin: 5px; /* Add margin around the body */
        }

        /* Main container that holds all the elements */
        .main-container {
            display: flex; /* Use flexbox layout */
            flex-direction: column; /* Arrange items in a column */
            align-items: center; /* Center the items horizontally */
        }
        h1 {
            margin-top: 0; /* Reduce space above the header */
            margin-bottom: 5px; /* Adjust space below the header */
        }
        /* Styling for the Connect button */
        #connect-btn {
            margin-top: 5px; /* Adjust space above the Connect button */
            margin-bottom: 5px; /* Optional margin for spacing, can be adjusted */
        }

        /* Container for the columns of buttons */
        .columns {
            display: flex; /* Use flexbox layout for the columns */
            justify-content: center; /* Center the columns horizontally */
            gap: 10px; /* Space between the two columns */
        }

        /* Styling for each individual column of buttons */
        .column {
            display: flex; /* Use flexbox layout within each column */
            flex-direction: column; /* Arrange buttons vertically within each column */
            align-items: center; /* Center the buttons horizontally within the column */
        }

        /* Container for button groups, allowing buttons to wrap if needed */
        .button-group {
            display: flex; /* Use flexbox layout for button group */
            flex-wrap: wrap; /* Allow buttons to wrap onto the next line if needed */
            justify-content: center; /* Center the buttons horizontally */
            gap: 10px; /* Space between buttons */
            margin-top: 10px; /* Optional margin for spacing above the button group */
        }

        /* Button styling */
        button {
            min-width: 150px; /* Ensure buttons have a consistent minimum width */
            padding: 10px 20px; /* Add padding to make buttons larger */
            font-size: 16px; /* Set font size for button text */
            cursor: pointer; /* Change cursor to pointer on hover */
            background-color: #007bff; /* Button background color */
            color: white; /* Set text color */
            border: none; /* Remove default button border */
            border-radius: 5px; /* Rounded corners for the button */
            transition: background-color 0.3s ease; /* Smooth transition for background color change */
            text-align: center; /* Prevent text from wrapping within button */
            white-space: nowrap; /* Prevent text from wrapping to the next line */
            margin-bottom: 3px; /* Space between buttons vertically */
        }

        /* Button hover effect */
        button:hover {
            background-color: #0056b3; /* Change background color on hover */
        }

        /* Disabled button styling */
        button:disabled {
            background-color: #cccccc; /* Set background color to gray */
            cursor: not-allowed; /* Change cursor to indicate that the button is disabled */
        }

    </style>
</head>
<body>
    <div class="main-container">
        <h1>Paddle Controller</h1>
        <button id="connect-btn">Connect</button>

        <div class="columns">
            <!-- Left column for FSR/Step-related buttons -->
            <div class="column">
                <button id="fsr-btn" disabled>Grip Unk</button>
                <div id="fsr-value" class="value-display">FSR: -- Step: --</div>
            </div>

            <!-- Right column for X Angle-related buttons -->
            <div class="column">
                <button id="xangle-btn" disabled>X Angle Unk</button>
                <div id="xangle-value" class="value-display">X Angle: --</div>
            </div>
        </div>
    </div>

    <script>
        let device;
        let server;
        let uartService;
        let txCharacteristic;
        let rxCharacteristic;
        let isConnected = false;
        let xAngleThreshold = -3.0; // Default X Angle threshold value
        let xHapticIntensity = 50; // Default X Haptic intensity value

        const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
        const TX_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
        const RX_CHAR_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

        const connectBtn = document.getElementById('connect-btn');
        const fsrBtn = document.getElementById('fsr-btn');
        const fsrValue = document.getElementById('fsr-value');
        const xangleBtn = document.getElementById('xangle-btn');
        const xangleValue = document.getElementById('xangle-value');

        async function connect() {
            try {
                if (!isConnected) {
                    console.log('Requesting Bluetooth device...');
                    device = await navigator.bluetooth.requestDevice({
                        filters: [{ services: [SERVICE_UUID] }]
                    });

                    console.log('Connecting to GATT server...');
                    server = await device.gatt.connect();

                    console.log('Getting UART service...');
                    uartService = await server.getPrimaryService(SERVICE_UUID);

                    console.log('Getting TX and RX characteristics...');
                    txCharacteristic = await uartService.getCharacteristic(TX_CHAR_UUID);
                    rxCharacteristic = await uartService.getCharacteristic(RX_CHAR_UUID);

                    console.log('Starting notifications...');
                    await rxCharacteristic.startNotifications();
                    rxCharacteristic.addEventListener('characteristicvaluechanged', handleNotifications);

                    // Update UI on successful connection
                    console.log('Connected successfully.');
                    isConnected = true;
                    connectBtn.textContent = 'Disconnect';
                    fsrBtn.disabled = false;
                    xangleBtn.disabled = false;

                    // Query initial statuses
                    console.log('Querying initial statuses...');
                    await Promise.all([getFSRStatus(), getXangleStatus()]);
                } else {
                    // Disconnect from the device
                    console.log('Disconnecting from Bluetooth device...');
                    if (device && device.gatt.connected) {
                        await device.gatt.disconnect();
                    }
                    isConnected = false;
                    connectBtn.textContent = 'Connect';
                    fsrBtn.disabled = true;
                    xangleBtn.disabled = true;
                    fsrBtn.textContent = 'Grip Unk';
                    xangleBtn.textContent = 'X Angle Unk';
                    fsrValue.textContent = 'FSR: --';
                    xangleValue.textContent = 'X Angle: --';
                }
            } catch (error) {
                console.error('Bluetooth connection failed:', error);
                alert('Failed to connect. Please ensure the device is powered on and in pairing mode.');
            }
        }

        async function toggleFSR() {
            if (!txCharacteristic) {
                alert('Not connected to paddle!');
                return;
            }
            try {
                const command = 'TOGGLE_FSR\n';
                await txCharacteristic.writeValue(new TextEncoder().encode(command));
            } catch (error) {
                console.error('Error toggling FSR:', error);
            }
        }

        async function getFSRStatus() {
            if (!txCharacteristic) return;
            try {
                const command = 'GET_FSR\n';
                await txCharacteristic.writeValue(new TextEncoder().encode(command));
            } catch (error) {
                console.error('Error sending GET_FSR command:', error);
            }
        }

        async function toggleXangle() {
            if (!txCharacteristic) {
		alert('Not connected to paddle!');
		return;
	    }
            try {
                const command = 'TOGGLE_XANGLE\n';
                await txCharacteristic.writeValue(new TextEncoder().encode(command));
            } catch (error) {
                console.error('Error toggling Xangle:', error);
            }
        }

        async function getXangleStatus() {
            if (!txCharacteristic) return;
            try {
                const command = 'GET_XANGLE\n';
                await txCharacteristic.writeValue(new TextEncoder().encode(command));
            } catch (error) {
                console.error('Error sending GET_XANGLE command:', error);
            }
        }

        let currentFSR = '--';
        let currentStep = '--';



        function handleNotifications(event) {
            const value = new TextDecoder().decode(event.target.value).trim();
            console.log(`Received: ${value}`);

         if (value.includes('FSR ENABLED')) {
            fsrBtn.textContent = 'Turn Grip Off';
        } else if (value.includes('FSR DISABLED')) {
            fsrBtn.textContent = 'Turn Grip On';
        } else if (value.startsWith('FSR:')) {
            // Update current FSR value
            currentFSR = value.split(':')[1].trim();
            fsrValue.textContent = `FSR: ${currentFSR} Step: ${currentStep}`;
        } else if (value.startsWith('STEP:')) {
            // Update current Step value
            currentStep = value.split(':')[1].trim();
            fsrValue.textContent = `FSR: ${currentFSR} Step: ${currentStep}`;
        } else if (value.includes('XANGLE ENABLED')) {
            xangleBtn.textContent = 'Turn X Angle Off';
        } else if (value.includes('XANGLE DISABLED')) {
            xangleBtn.textContent = 'Turn X Angle On';
        } else if (value.startsWith('XANGLE:')) {
            // Update the Xangle display
            const xAngleValue = value.split(':')[1].trim();
            xangleValue.textContent = `X Angle: ${xAngleValue}`;
        } else {
            console.log(`Unrecognized message: ${value}`);
        }
    }
        connectBtn.addEventListener('click', connect);
        fsrBtn.addEventListener('click', toggleFSR);
        xangleBtn.addEventListener('click', toggleXangle);

    </script>
</body>
</html>
